---
title: 圖論初體驗
description: 一篇圖論的介紹。
slug: 20240417-graph-theory
lang: zh-tw
date: 2024-04-17
type: Post
tags:
  - math
  - computer science
---

圖論是一門談「圖」的理論，先等等……，不是照片或圖片喔！這裡的圖代表的是由點
（vertex）和邊（edge）所構成的物件，一個邊連接兩個點，或同一個點。
透過圖論，我們可以解決許多看似難以分析的問題，所以請繼續讀下去。

## 正式定義

一個圖是一個集合，這個集合$G=V+E$，$V$為點集合，$E$為邊集合。
接下來定義一些術語：

- 自環：一個自環便是$e(n,n)$。
- 循環：一個圖的循環是可以透過路徑從一點出發回到同點的路徑。
- 權重：點和邊都可以有特定數值或資訊。

圖由一些特質可以細分為許多種，
最簡單的圖是*簡單圖*，一種沒有自環（連同樣點的邊）也沒有方向的圖。
第二簡單的便是 DAG（Directed Acyclic Graph），又稱為有向無環圖。

## 拓樸性質

由於圖是代表元素關係的方式，圖的形狀並不是我們關心的，
因此會出現同構（isomorphism）現象。一個圖的點可以隨意放置；邊可以彎曲亂繞，
不會影響到圖的架構，這是圖的特性。

## 圖的實作

圖的實作方法有很多種，不過複雜度各有不同。

1. 第一種是使用相鄰矩陣

```c
#include <stdio.h>
#define MAX_NODES 100

size_t nodes = 0;
int adj[MAX_NODES][MAX_NODES] = {0};

int main()
{
    printf("nodes: ");
    scanf("%u", &nodes);
    printf("input edges x y (until -1):\n");
    while(1)
    {
        int x,y;
        scanf("%d %d", &x, &y);
        if(x < 0 || y < 0) break;
        adj[x][y] = adj[y][x] = 1;
    }
    for(size_t i = 0; i < nodes; i++)
    {
        printf("adjs of %d are: ", i);
        for(size_t j = 0; j < nodes; j++)
        {
            if(i == j || !adj[i][j]) continue;
            printf("%d ", j);
        }
        printf("\n");
    }
    return 0;
}
```

2. 第二種是使用相鄰存點

```c
#include <stdio.h>

#define MAX_NODES 100

size_t nodes = 0;
size_t adj[MAX_NODES][MAX_NODES + 1] = {0};

int main()
{
    printf("nodes: ");
    scanf("%u", &nodes);
    printf("input edges x y (until -1):\n");
    while(1)
    {
        int x,y;
        scanf("%d %d", &x, &y);
        if(x < 0 || y < 0) break;
        adj[x][adj[x][MAX_NODES]++] = y;
        adj[y][adj[y][MAX_NODES]++] = x;
    }
    for(size_t i = 0; i < nodes; i++)
    {
        printf("adjs of %d are: ", i);
        for(size_t j = 0; j < adj[i][MAX_NODES]; j++)
        {
            printf("%u ", adj[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```

在讀取上，相鄰矩陣最糟情況為$O(n^2)$，而相鄰存點是$O(n)$，
不過在檢測是否有邊的時候，相鄰矩陣是$O(1)$，而相鄰存點是$O(n)$，
時間差異非常大。

## 特殊圖

以下將介紹一些有特殊應用的圖。

### 二分圖

一個二分圖由兩個只有點的圖所組成的，因此$G=(E_1 + E_2, V)$，
因為可以用來表達多種問題，像是配對組隊問題，因此被廣泛應用。

### 網路流

一個符合網路流的圖中，邊上都有權重且都有方向，圖上所有點的入邊的權重相加和出邊的權重相加一樣大。
網路流可以用來解決優化排程問題，搭配特定演算法可以大幅加速。一個網路流有源頭（source）與終點（sink），
分別代表流入總流量與流出總流量，需要互相抵銷。

## 圖的相關演算法

### 深度／廣度優先搜尋／走訪

談到圖的演算法，絕對要先講到經典的 DFS 與 BFS。其中 DFS 指的是在走訪時，直到窮盡某一狀態結束，
且此走訪模式可以被表示為一種堆疊，因此 DFS 可以使用遞迴製作。相對的，
BFS 是走訪時盡可能先拜訪相鄰點，通常使用佇列實作。DFS 與 BFS 的通用版本（Generalized Version）
的時間複雜度都是非多項式時間，因此需要再透過資料結構優化。

### 最大匹配問題

在一張圖中，一個匹配是邊集合的子集合，匹配中的邊與點集合所組成的圖中，
每個點最多只能連接一個點，這件事看起來像是把點兩兩匹配，因此被稱為匹配。
最大匹配即在探討如何得到最多個倆倆匹配的點，時間複雜度非常可觀，媲美 DFS 的複雜度，
不過，有些演算法使這件事簡單化許多。

1. 柯尼西定理：由 Dénes Kőnig 於 1931 提出，使用交錯路（alternating path，即由非匹配邊出發，
   交錯走匹配與非匹配邊的道路）證明此定理（證明略），他提出以下論點，擷取自維基百科：
   「在任意二部圖中，最大匹配的邊數等於最小頂點覆蓋的頂點數。」透過此定理，
   我們可以透過找到最小點覆蓋找到最大匹配，最簡單的實作方法便是 DFS。

2. 埃特蒙德-卡普演算法：將二分圖的$U$向與$V$向各自接上源頭與終點，然後將每個邊的權重設為一，
   則尋找最大流的時候便是在尋找最大匹配了。因為要找到網路流，勢必要將一個點連向的其他點刪去，剩下一點，
   這樣的剪裁步驟最大化，找到的便是最小點覆蓋，由柯尼西定理可知推得最大匹配。

3. 福特-富爾克森演算法：埃特蒙德-卡普演算法的 DFS 版，速度其實沒有差很多，理論值很大罷了。
